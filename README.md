# 1C-screening-task

[![Documentation](https://img.shields.io/badge/Documentation-latest-blue.svg)](https://ajreme.github.io/1C-screening-task/)

Решение очень простое и использует бор как основу.

1) На каждом ноде будем писать максимальный текущий приоритет среди данного поддерева и приоритет конкретного слова. Приоритет - число раз, которое слово уже предлагалось.
2) Если было добавлено новое слово, то его приоритет - нулевой.
3) Если слово удаляется (*не имплементировано*), то для каждого нода обновляем приоритет минимальным среди всех его детей.
4) Поиск очень прост: сначала ищем префикс слова, которое предложено добавить, тривиальным образом. Если мы не пришли к листу или ветви (такое может быть, если в словаре, к примеру, нет слов), то закончим работу. Иначе идем к ребенку с наивысшим приоритетом.

## Исходники

В папке `src/` можно найти файл с бором `trie.hpp` (header-only), `completor.hpp` и `completor.cpp` (само автодополнение) и `main.cpp` - простая консольная утилита для демонстрирования работы. Она принимает на вход число слов в словаре, сами слова и затем число запросов и сами запросы соответственно. Если дополнить нечем, возвращается пустая строка.

Пример:
```
5
hello
im
bob
bobby
bobty
5
hel
noword
bob
bobb
bobt
```
Вывод:
```
hello

bob
bobby
bobty
```

Структура позволяет легко написать программу, которая будет также легко добавлять и удалять слова. Обратите внимание, что я постарался написать бор максимально универсальным: он использует итераторы, что позволяет с удобством обойти его, а сам он принимает на вход любой контейнер, по которому можно итерироваться - достаточно `ForwardIt`.

## Документация

(Которая не написана, но настроена) есть на [Github Pages](https://ajreme.github.io/1C-screening-task/). Системы CI не настраивались, потому что кроме пуша документации тут ничего нельзя сделать.

## Бинарник

Используется сборка с помощью `meson`. Для сборки используйте такие команды:

```
$ meson . build/
$ ninja -C build/

# Далее - по желанию
$ ninja -C build/ clang-format
$ ninja -C build/ clang-tidy
$ ninja -C build/ generate-docs  # Требуется doxygen
```

## Что можно улучшить?

- Написать документацию, а не быть симулянтом и просто настроить ее сборку :)
- На данный момент - работаем только с английским алфавитом. Можно вообще с любыми символами, но для этого внутри бора лучше использовать хеш-таблицы или сбалансированные бинарные деревья и т.п, сейчас - только массив, что даст большой overhead по памяти неоправдано в случае использования с широким алфавитом.
- Бор можно сжать. Эффективно, например, когда слова большие.
- Протестировать код.

## Note от 00:25 ночи

Я немного облажался и не успел написать полноценную работающую версию *с приоритетами* (без приоритетов - в папке `src`), однако это, при наличии у меня еще 20 минут, легко решается. Что успел - в папке `temp`.
