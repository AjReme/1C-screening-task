# 1C-screening-task

[![Documentation](https://img.shields.io/badge/Documentation-latest-blue.svg)](https://ajreme.github.io/1C-screening-task/)

Решение очень простое и использует бор как основу.

1) На каждом ноде будем писать максимальный текущий приоритет среди данного поддерева и приоритет конкретного слова. Приоритет - число раз, которое слово уже предлагалось.
2) Если было добавлено новое слово, то его приоритет - нулевой.
3) Если слово удаляется (*не имплементировано*), то для каждого нода обновляем приоритет минимальным среди всех его детей.
4) Поиск очень прост: сначала ищем префикс слова, которое предложено добавить, тривиальным образом. Если мы не пришли к листу или ветви (такое может быть, если в словаре, к примеру, нет слов), то закончим работу. Иначе идем к ребенку с наивысшим приоритетом.

## Бинарник

Используется сборка с помощью `meson`. Для сборки используйте такие команды:

```
$ meson . build/
$ ninja -C build/

# Далее - по желанию
$ ninja -C build/ clang-format
$ ninja -C build/ clang-tidy
$ ninja -C build/ generate-docs  # Требуется doxygen
```

## Что можно улучшить?

- Написать документацию, а не быть симулянтом и просто настроить ее сборку и GitHub Pages :)
- На данный момент - работаем только с английским алфавитом. Можно вообще с любыми символами, но для этого внутри бора лучше использовать хеш-таблицы или сбалансированные деревья и т.д, сейчас - только массив, что даст большой overhead по памяти неоправдано.
- Бор можно сжать. Эффективно, например, когда слова большие.
- Протестировать код.
